const std = @import("std");

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    const args = try std.process.argsAlloc(allocator);
    defer std.process.argsFree(allocator, args);

    var input_path: []const u8 = "config/model_context.json";
    var output_path: []const u8 = "src/model_context_data.zig";

    var i: usize = 1;
    while (i < args.len) : (i += 1) {
        const arg = args[i];
        if (std.mem.eql(u8, arg, "--input")) {
            i += 1;
            if (i >= args.len) return error.MissingInputValue;
            input_path = args[i];
        } else if (std.mem.eql(u8, arg, "--output")) {
            i += 1;
            if (i >= args.len) return error.MissingOutputValue;
            output_path = args[i];
        } else if (std.mem.eql(u8, arg, "--help")) {
            std.debug.print(
                "Usage: {s} [--input path] [--output path]\n",
                .{args[0]},
            );
            return;
        } else {
            return error.UnknownFlag;
        }
    }

    const max_bytes: usize = 4 * 1024 * 1024;
    const json_bytes = try std.fs.cwd().readFileAlloc(allocator, input_path, max_bytes);
    defer allocator.free(json_bytes);

    var arena = std.heap.ArenaAllocator.init(allocator);
    defer arena.deinit();

    const parsed = try std.json.parseFromSliceLeaky(std.json.Value, arena.allocator(), json_bytes, .{});
    const obj = switch (parsed) {
        .object => |o| o,
        else => return error.ExpectedObject,
    };

    var entries = std.ArrayListUnmanaged(Entry){};
    defer entries.deinit(allocator);

    var it = obj.iterator();
    while (it.next()) |entry| {
        const key = entry.key_ptr.*;
        const converted = try valueToU32(entry.value_ptr.*);
        const duped_key = try allocator.dupe(u8, key);
        try entries.append(allocator, .{ .key = duped_key, .value = converted });
    }

    std.mem.sort(Entry, entries.items, {}, entryLessThan);

    var deduped = std.ArrayListUnmanaged(Entry){};
    defer {
        for (deduped.items) |entry| allocator.free(entry.key);
        deduped.deinit(allocator);
    }

    for (entries.items) |entry| {
        if (deduped.items.len != 0) {
            const last_index = deduped.items.len - 1;
            const last = deduped.items[last_index];
            if (std.mem.eql(u8, last.key, entry.key)) {
                allocator.free(last.key);
                deduped.items[last_index] = entry;
                continue;
            }
        }
        try deduped.append(allocator, entry);
    }

    const dir = std.fs.path.dirname(output_path);
    if (dir) |d| try std.fs.cwd().makePath(d);

    var file = try std.fs.cwd().createFile(output_path, .{ .truncate = true });
    defer file.close();
    var writer_buffer: [4096]u8 = undefined;
    var writer = file.writer(&writer_buffer);

    try writer.interface.writeAll("// Code generated by hack/generate_model_context_table.zig; DO NOT EDIT.\n");
    try writer.interface.writeAll("pub const Entry = struct { key: []const u8, value: u32 };\n");
    try writer.interface.writeAll("pub const entries = [_]Entry{\n");
    for (deduped.items) |entry| {
        try writer.interface.writeAll("    .{ .key = ");
        try writeStringLiteral(&writer.interface, entry.key);
        try writer.interface.writeAll(", .value = ");
        var value_buf: [32]u8 = undefined;
        const value_slice = try std.fmt.bufPrint(&value_buf, "{d}", .{entry.value});
        try writer.interface.writeAll(value_slice);
        try writer.interface.writeAll(" },\n");
    }
    try writer.interface.writeAll("};\n");
    try writer.interface.flush();
}

const Entry = struct {
    key: []const u8,
    value: u32,
};

fn entryLessThan(_: void, lhs: Entry, rhs: Entry) bool {
    return std.mem.lessThan(u8, lhs.key, rhs.key);
}

fn valueToU32(value: std.json.Value) !u32 {
    return switch (value) {
        .integer => |int_value| blk: {
            if (int_value < 0) break :blk error.InvalidNumber;
            const casted = std.math.cast(u32, int_value) orelse break :blk error.InvalidNumber;
            break :blk casted;
        },
        .float => |float_value| blk: {
            if (!std.math.isFinite(float_value)) break :blk error.InvalidNumber;
            if (float_value < 0) break :blk error.InvalidNumber;
            if (float_value > @as(f64, @floatFromInt(std.math.maxInt(u32)))) break :blk error.InvalidNumber;
            break :blk @intFromFloat(float_value);
        },
        .string => |str| parseString(str),
        else => error.InvalidNumber,
    };
}

fn parseString(str: []const u8) !u32 {
    const trimmed = std.mem.trim(u8, str, " \t\r\n");
    if (trimmed.len == 0) return error.InvalidNumber;
    return std.fmt.parseUnsigned(u32, trimmed, 10);
}

fn writeStringLiteral(writer: *std.Io.Writer, bytes: []const u8) !void {
    try writer.writeByte('"');
    for (bytes) |c| {
        switch (c) {
            '"' => try writer.writeAll("\\\""),
            '\\' => try writer.writeAll("\\\\"),
            '\n' => try writer.writeAll("\\n"),
            '\r' => try writer.writeAll("\\r"),
            '\t' => try writer.writeAll("\\t"),
            else => {
                if (c >= 0x20 and c <= 0x7e) {
                    try writer.writeByte(c);
                } else {
                    try writer.writeAll("\\x");
                    try writer.writeByte(hexDigit(@intCast((c >> 4) & 0xF)));
                    try writer.writeByte(hexDigit(c & 0xF));
                }
            },
        }
    }
    try writer.writeByte('"');
}

fn hexDigit(value: u8) u8 {
    return "0123456789abcdef"[value];
}
